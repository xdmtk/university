/*  My output

Testing Seasoned Programmer's program.
QS: outside-in partition, random pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, 1 random pivot partition, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, 2 random pivot partition, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: outside-in partition, lf pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, lf pivot, cutoff=50: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: outside-in partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, 1 random pivot partition, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, 2 random pivot partition, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: outside-in partition, lf pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
QS: left-to-right, lf pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Almost QS: outside-in partition, random pivot, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Almost QS: left-to-right, 1 random pivot partition, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Almost QS: left-to-right, 2 random pivot partition, cutoff=2: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
HeapSort: top-down build heap: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
HeapSort: bottom-up build heap: 
    26.25.24.23.22.21.20.19.18.17.16.15.14.13.12.11.10.9.8.7.6.5.4.3.2.1.0.
Bigger, QS: outside-in partition, random pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, 1 random pivot partition, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, 2 random pivot partition, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: outside-in partition, lf pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, lf pivot, cutoff=50:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: outside-in partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, 1 random pivot partition, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, 2 random pivot partition, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: outside-in partition, lf pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, QS: left-to-right, lf pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Almost QS: outside-in partition, random pivot, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Almost QS: left-to-right, 1 random pivot partition, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, Almost QS: left-to-right, 2 random pivot partition, cutoff=2:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, HeapSort: top-down build heap:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.
Bigger, HeapSort: bottom-up build heap:
    100.631.1162.1693.2224.2755.3286.3817.4348.4879.5410.5941.6472.7003.7534.8065.8596.
    9127.9658.10189.10720.11251.11782.12313.12844.13375.13906.14437.14968.15499.16030.
    16561.17092.17623.18154.18685.19216.19747. done.

Testing Seasoned Programmer's sorts on a huge array.

Java's QuickSort on random data runs in 6.842 seconds.
Java's QuickSort on the test sets runs in 1.706 seconds.


Seasoned Programmer's QS: outside-in partition, random pivot, cutoff=50
    on all random values runs in 5.746 seconds.      Java Ratio = 0.83
    on the test sets runs in 2.308 seconds.          Java Ratio = 1.35

Seasoned Programmer's QS: left-to-right, 1 random pivot partition, cutoff=50
    on all random values runs in 5.028 seconds.      Java Ratio = 0.73
    on the test sets runs in 3.354 seconds.          Java Ratio = 1.96

Seasoned Programmer's QS: left-to-right, 2 random pivot partition, cutoff=50
    on all random values runs in 5.446 seconds.      Java Ratio = 0.79
    on the test sets runs in 3.237 seconds.          Java Ratio = 1.89

Seasoned Programmer's QS: outside-in partition, lf pivot, cutoff=50
    on all random values runs in 4.352 seconds.      Java Ratio = 0.63

Seasoned Programmer's QS: left-to-right, lf pivot, cutoff=50
    on all random values runs in 4.667 seconds.      Java Ratio = 0.68

Seasoned Programmer's QS: outside-in partition, random pivot, cutoff=2
    on all random values runs in 6.767 seconds.      Java Ratio = 0.98
    on the test sets runs in 3.753 seconds.          Java Ratio = 2.19

Seasoned Programmer's QS: left-to-right, 1 random pivot partition, cutoff=2
    on all random values runs in 6.438 seconds.      Java Ratio = 0.94
    on the test sets runs in 4.155 seconds.          Java Ratio = 2.43

Seasoned Programmer's QS: left-to-right, 2 random pivot partition, cutoff=2
    on all random values runs in 6.843 seconds.      Java Ratio = 1.00
    on the test sets runs in 4.994 seconds.          Java Ratio = 2.92

Seasoned Programmer's QS: outside-in partition, lf pivot, cutoff=2
    on all random values runs in 5.494 seconds.      Java Ratio = 0.80

Seasoned Programmer's QS: left-to-right, lf pivot, cutoff=2
    on all random values runs in 5.464 seconds.      Java Ratio = 0.79

Seasoned Programmer's Almost QS: outside-in partition, random pivot, cutoff=2
    on all random values runs in 6.726 seconds.      Java Ratio = 0.98
    on the test sets runs in 3.685 seconds.          Java Ratio = 2.16

Seasoned Programmer's Almost QS: left-to-right, 1 random pivot partition, cutoff=2
    on all random values runs in 6.357 seconds.      Java Ratio = 0.92
    on the test sets runs in 4.043 seconds.          Java Ratio = 2.36

Seasoned Programmer's Almost QS: left-to-right, 2 random pivot partition, cutoff=2
    on all random values runs in 6.729 seconds.      Java Ratio = 0.98
    on the test sets runs in 4.862 seconds.          Java Ratio = 2.84

Seasoned Programmer's HeapSort: top-down build heap
    on all random values runs in 11.718 seconds.      Java Ratio = 1.71
    on the test sets runs in 5.832 seconds.          Java Ratio = 3.41

Seasoned Programmer's HeapSort: bottom-up build heap
    on all random values runs in 11.564 seconds.      Java Ratio = 1.69
    on the test sets runs in 5.210 seconds.          Java Ratio = 3.05

Done testing Seasoned Programmer methods.

*/

import java.io.*; // for IOException
import java.util.Arrays; // to compare your sort against Java's

public class TestSorts1 {

	public static void main(String[] args) throws IOException {

		final int largeSize = 10000000;
		int[] number, goodone;
		int n, differ, sort, fill, i;
		boolean[] Sort_OK = { true, true, true, true, true, true, true, true,
				true, true, true, true, true, true, true };
		long before, after, yourtotal, javarandomtotal, javaothertotal;
		number = new int[20000];
		goodone = new int[20000];
		String[] SortType = {
				"QS: outside-in partition, random pivot, cutoff=50",					//  1
				"QS: left-to-right, 1 random pivot partition, cutoff=50",				//  2
				"QS: left-to-right, 2 random pivot partition, cutoff=50",				//  3
				"QS: outside-in partition, lf pivot, cutoff=50",						//  4
				"QS: left-to-right, lf pivot, cutoff=50",								//  5
				"QS: outside-in partition, random pivot, cutoff=2",						//  6
				"QS: left-to-right, 1 random pivot partition, cutoff=2",				//  7
				"QS: left-to-right, 2 random pivot partition, cutoff=2",				//  8
				"QS: outside-in partition, lf pivot, cutoff=2",							//  9
				"QS: left-to-right, lf pivot, cutoff=2",								// 10
				"Almost QS: outside-in partition, random pivot, cutoff=2",				// 11
				"Almost QS: left-to-right, 1 random pivot partition, cutoff=2",			// 12
				"Almost QS: left-to-right, 2 random pivot partition, cutoff=2",			// 13
				"HeapSort: top-down build heap",										// 14
				"HeapSort: bottom-up build heap" };										// 15
		String[] FillType = { "Increasing", "Decreasing", "Random", "Constant",
				"Mids" };

		int numSorts = SortType.length;
		System.out.println("Testing " + ArraySorts.myName() + "'s program.");

		// First check to see if they sort small arrays properly
		for (sort = 0; sort < numSorts; sort++) {
			System.out.print(SortType[sort] + ": \n    ");
			for (n = 26; n >= 0 && Sort_OK[sort]; n--) {
				System.out.print(n + ".");

				for (fill = 0; fill < FillType.length && Sort_OK[sort]; fill++) {
					fillArray(fill, number, 0, n);
					for (i = 0; i < n; i++)
						goodone[i] = number[i];
					callSort(sort + 1, number, n);
					Arrays.sort(goodone, 0, n);
					differ = same(goodone, number, n);
					if (differ != -1) {
						System.out.println();
						System.out.println("*** " + FillType[fill]
								+ " sorting error: " + SortType[sort]
								+ ", position #" + differ);
						System.out.println("*** No more " + SortType[sort]
								+ "s will be tested.  Correct values and "
								+ ArraySorts.myName() + "'s values follow.");
						Sort_OK[sort] = false;
						mydisplay(goodone, n);
						mydisplay(number, n);
					}
				}
			}
			System.out.println();
		}

		// Now check larger arrays
		for (sort = 0; sort < numSorts; sort++) {
			System.out.print("Bigger, " + SortType[sort] + ":\n    ");
			for (n = 100; n <= 20000 && Sort_OK[sort]; n = n + 531) {
				System.out.print(n + ".");
				if (n == 8596 || n == 16030) {
					System.out.println();
					System.out.print("    ");
				}

				for (fill = 0; fill < FillType.length && Sort_OK[sort]; fill++) {
					fillArray(fill, number, 1, n);
					for (i = 0; i < n; i++)
						goodone[i] = number[i];
					callSort(sort + 1, number, n);
					Arrays.sort(goodone, 0, n);
					differ = same(goodone, number, n);
					if (differ != -1) {
						System.out.println();
						System.out.println("*** " + FillType[fill]
								+ " sorting error: " + SortType[sort]
								+ ", position #" + differ);
						System.out.println("*** No more " + SortType[sort]
								+ "s will be tested.  Correct values and "
								+ ArraySorts.myName() + "'s values follow.");
						Sort_OK[sort] = false;
					}
				}
			}
			System.out.println(" done.");
		}
		System.out.println();

		// Now see how fast your sorts really are
		System.out.println("Testing " + ArraySorts.myName()
				+ "'s sorts on a huge array.");
		number = new int[largeSize];
		javarandomtotal = 0;
		for (fill = 0; fill < 5; fill++) {
			fillArray(2, number, 1, largeSize);
			before = System.currentTimeMillis();
			Arrays.sort(number);
			after = System.currentTimeMillis();
			javarandomtotal = javarandomtotal + after - before;
		}
		System.out.println("\nJava's QuickSort on random data runs in "
				+ javarandomtotal / 1000 + "." + millis(javarandomtotal % 1000)
				+ " seconds.");

		javaothertotal = 0;
		for (fill = 0; fill < 5; fill++) {
			fillArray(fill, number, 1, largeSize);
			before = System.currentTimeMillis();
			Arrays.sort(number);
			after = System.currentTimeMillis();
			javaothertotal = javaothertotal + after - before;
		}
		System.out.println("Java's QuickSort on the test sets runs in "
				+ javaothertotal / 1000 + "." + millis(javaothertotal % 1000)
				+ " seconds.");
		System.out.println();

		for (int sortNum = 1; sortNum <= numSorts; sortNum++) {
			if (Sort_OK[sortNum - 1]) {
				yourtotal = 0;
				for (fill = 0; fill < 5; fill++) {
					fillArray(2, number, 1, largeSize);
					before = System.currentTimeMillis();
					callSort(sortNum, number, largeSize);
					after = System.currentTimeMillis();
					yourtotal = yourtotal + after - before;
				}
				System.out.print("\n" + ArraySorts.myName() + "'s "
						+ SortType[sortNum - 1]
						+ "\n    on all random values runs in " + yourtotal
						/ 1000 + "." + millis(yourtotal % 1000) + " seconds.");
				System.out
						.println("      Java Ratio = "
								+ (yourtotal / javarandomtotal)
								+ "."
								+ hundreds((int) (((float) (yourtotal)
										/ javarandomtotal - (yourtotal / javarandomtotal)) * 100)));
				if ( sortNum != 4 && sortNum != 5 && sortNum != 9 && sortNum != 10 ) { 
					yourtotal = 0;
					for (fill = 0; fill < 5; fill++) {
						fillArray(fill, number, 1, largeSize);
						before = System.currentTimeMillis();
						callSort(sortNum, number, largeSize);
						after = System.currentTimeMillis();
						yourtotal = yourtotal + after - before;
					}
					System.out.print("    on the test sets runs in "
							+ yourtotal / 1000 + "." + millis(yourtotal % 1000)
							+ " seconds.");
					System.out
							.print("          Java Ratio = "
									+ (yourtotal / javaothertotal)
									+ "."
									+ hundreds((int) (((float) (yourtotal)
											/ javaothertotal - (yourtotal / javaothertotal)) * 100)));
					System.out.println();
				}
			} else {
				System.out.println(ArraySorts.myName() + "'s "
						+ SortType[sortNum - 1] + " not tested.");
				System.out.println();
			}
		}
		System.out.println("\nDone testing " + ArraySorts.myName()
				+ " methods.");
	}

	private static void callSort(int which, int[] a, int n) {
		if (which == 1)
			ArraySorts.QuickSort1(a, n, 50);
		else if (which == 2)
			ArraySorts.QuickSort2(a, n, 50);
		else if (which == 3)
			ArraySorts.QuickSort3(a, n, 50);
		else if (which == 4)
			ArraySorts.QuickSort4(a, n, 50);
		else if (which == 5)
			ArraySorts.QuickSort5(a, n, 50);
		else if (which == 6)
			ArraySorts.QuickSort1(a, n, 2);
		else if (which == 7)
			ArraySorts.QuickSort2(a, n, 2);
		else if (which == 8)
			ArraySorts.QuickSort3(a, n, 2);
		else if (which == 9)
			ArraySorts.QuickSort4(a, n, 2);
		else if (which == 10)
			ArraySorts.QuickSort5(a, n, 2);
		/*
		else if (which == 11)
			ArraySorts.AlmostQS1(a, n, 2);
		else if (which == 12)
			ArraySorts.AlmostQS2(a, n, 2);
		else if (which == 13)
			ArraySorts.AlmostQS3(a, n, 2);
		else if (which == 14)
			ArraySorts.HeapSortTD(a, n);
		else if (which == 15)
			ArraySorts.HeapSortBU(a, n);
		else
			System.out.println("No such sort " + which + ".");
		*/
	}

	private static void fillArray(int fillNumber, int[] number, int BigorSmall,
			int n) {
		if (fillNumber == 0)
			fillIncreasing(number, n);
		else if (fillNumber == 1)
			fillDecreasing(number, n);
		else if (fillNumber == 2) {
			if (BigorSmall == 0)
				fillRandomSmall(number, n);
			else
				fillRandomBig(number, n);
		} else if (fillNumber == 3)
			fillConstant(number, n);
		else if (fillNumber == 4)
			fillMids(number, n);
		else
			System.out.println("No such filling scheme.");
	}

	public static int same(int[] a, int[] b, int n) {
		int result = -1;
		for (int i = 0; (i < n) && (result == -1); i++)
			if (a[i] != b[i])
				result = i;
		return result;
	}

	public static void mydisplay(int[] a, int n) {
		for (int i = 0; i < n; i++)
			System.out.print(a[i] + " ");
		System.out.println();
	}

	public static void fillMids(int[] a, int n) {
		fillMids(a, 0, n - 1, 0);
	}

	private static void fillMids(int[] a, int lf, int rt, int ct) {

		while (lf <= rt) {
			a[lf] = ct;
			ct++;
			lf++;
			a[rt] = ct;
			ct++;
			rt--;
		}
	}

	public static void fillConstant(int a[], int n) {
		int inc = n / Math.max(1, (int) Math.log((double) n));
		for (int i = 0; i < n; i++) {
			a[i] = 52;
		}
		for (int i = 0; i < n; i += inc) {
			if (i % 2 == 0)
				a[i] = 51;
			else
				a[i] = 53;
		}
	}

	public static void fillIncreasing(int[] a, int n) {
		for (int i = 0; i < n; i++)
			a[i] = i;
		if (n > 2) {
			a[n - 2] = 2;
			a[1] = n - 2;
		}
	}

	public static void fillDecreasing(int[] a, int n) {
		for (int i = 0; i < n; i++)
			a[i] = n - i - 1;
		if (n > 2) {
			a[n - 2] = n - 2;
			a[1] = 1;
		}
	}

	public static void fillRandomSmall(int a[], int n) {
		for (int i = 0; i < n; i++)
			a[i] = (int) (Math.random() * n);
	}

	public static void fillRandomBig(int a[], int n) {
		for (int i = 0; i < n; i++)
			a[i] = (int) (Math.random() * n * 10);
	}

	public static String millis(long n) {
		String rtn;
		if (n < 10)
			rtn = "00" + n;
		else if (n < 100)
			rtn = "0" + n;
		else
			rtn = String.valueOf(n);
		return rtn;
	}

	public static String hundreds(long n) {
		String rtn;
		if (n < 10)
			rtn = "0" + n;
		else
			rtn = String.valueOf(n);
		return rtn;
	}

}