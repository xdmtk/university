#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "main.h"
#include "parse.h"


char ** read_tokens(char * file_path, size_t *len, int mode) {

    /* Declarations */
    FILE * fp;
    char * token_buffer, c;
    struct token_indices t;
    int i, parse_status = PARSE_OK;

    /* Zero counters, allocate the buffer space and zero it out */
    t.buffer_index = t.token_count = t.bit_count = 0;
    token_buffer = malloc(sizeof(char)*BUFFER_SIZE);
    for (i=0; i < BUFFER_SIZE; ++i) token_buffer[i] = '0';

    /* For file reads, get a file handle to read */
    if (mode == READ_FROM_FILE)
        fp = fopen(file_path, "r");

    /* Begin reading character by character, calling fgetc() for file reads and getchar() for stdin reads */
    while (((c = (mode == READ_FROM_FILE ? fgetc(fp) : getchar())) != EOF) && (parse_status != PARSE_FAIL)) {

        /* Terminate stdin read on newline entry */
        if (mode == READ_FROM_STDIN && c == '\n') break;

        /* Parse the character and return a parse status */
        parse_status = tokenize(c, token_buffer, &t);
    }

    /* Increment the final token count after the last character has been parsed */
    *len = ++t.token_count;

    /* If parse status is OK, return the token list generated by append_tokens(), otherwise
     * return NULL */
    return parse_status != PARSE_FAIL ? append_tokens(token_buffer, &t) : NULL;
}

char ** append_tokens(char *tokens, struct token_indices *t) {

    int i;
    /* Allocate a list of char pointers */
    char ** token_list = malloc(sizeof(char *)*t->token_count);

    /* Begin allocating and copying tokens from the token buffer */
    for (i = 0; i < t->token_count; ++i) {

        token_list[i] = malloc(sizeof(char)*9);
        memcpy(token_list[i], tokens+(i*8), 8);

        /* Null terminate each string */
        token_list[i][8] = '\0';
    }

    /* Return the list of tokens */
    return token_list;
}

int tokenize(char c, char* token_buffer, struct token_indices *t) {

    /* If delimiter is reached before 8 bits, advance the buffer_index pointer
     * to the next set of 8 bits, reset the current bit count, and increment
     * the token counter */
    if (c == ' ' && t->buffer_index % 8) {
        t->buffer_index += 8 - (t->buffer_index % 8);
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* If no delimiter was found before the end of the 8 bits,
     * the input is incorrectly formatted and should be rejected */
    else if (c != ' ' && t->bit_count >= 8) {
        return PARSE_FAIL;
    }

    /* If we've hit the delimiter at the correct position, meaning
     * the user has entered 8 bits and then hit a space, reset the bit
     * counter, increment the token count and continue parsing */
    else if(c == ' ' && t->bit_count == 8) {
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* Last case represents entering an additional bit within the bounds
     * of the token. Record the character, increment the buffer index and
     * bit counter and continue parsing */
    else {
        token_buffer[t->buffer_index++] = c;
        t->bit_count++;
        return PARSE_OK;
    }
}
