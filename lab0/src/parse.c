#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* For read() declaration - unistd.h does not exist in Windows */
#ifdef __linux__
    #include <unistd.h>
#elif WIN32
    #include <io.h>
#endif

#include <lab0/main.h>
#include <lab0/parse.h>


char ** read_tokens(char * file_path, size_t *len, int mode) {

    /* Declarations */
    FILE * fp;
    char * token_buffer, read_token_buffer[BUFFER_SIZE], c;
    struct token_indices t;
    int i, parse_status = PARSE_OK;

    /* Zero counters, allocate the buffer space and zero it out */
    t.buffer_index = t.token_count = t.bit_count = t.read_buffer_index = 0;
    token_buffer = malloc(sizeof(char)*BUFFER_SIZE);
    for (i=0; i < BUFFER_SIZE; ++i) token_buffer[i] = '0';

    /* For file reads, get a file handle to read */
    fp = (mode == READ_FROM_FILE) ? fopen(file_path, "r") : NULL;

    /* Begin reading character by character, using read_char_primitive as a wrapper around read()
     * and mimic the functionality of fgetc() / getchar() */
    while (((c = read_char_primitive(fp, 0, mode, &t, read_token_buffer)) != EOF) && (parse_status != PARSE_FAIL)) {

        /* Terminate stdin read on newline entry */
        if (mode == READ_FROM_STDIN && c == '\n') break;

        /* Parse the character and return a parse status */
        parse_status = tokenize(c, token_buffer, &t);
    }

    /* Increment the final token count after the last character has been parsed */
    *len = ++t.token_count;

    /* If parse status is OK, return the token list generated by append_tokens(), otherwise
     * return NULL */
    return parse_status != PARSE_FAIL ? append_tokens(token_buffer, &t) : NULL;
}

char ** append_tokens(char *tokens, struct token_indices *t) {

    int i;
    /* Allocate a list of char pointers */
    char ** token_list = malloc(sizeof(char *)*t->token_count);

    /* Begin allocating and copying tokens from the token buffer */
    for (i = 0; i < t->token_count; ++i) {

        token_list[i] = malloc(sizeof(char)*9);
        memcpy(token_list[i], tokens+(i*8), 8);

        /* Null terminate each string */
        token_list[i][8] = '\0';
    }

    /* Return the list of tokens */
    return token_list;
}

int tokenize(char c, char* token_buffer, struct token_indices *t) {

    /* If we've hit a delimiter but have no bits entered yet
     * we can safely ignore. This can happen with input where tokens
     * have multiple spaces separating them
     *
     * Example: 1101       1110 01      1000
     */
    if ((c == ' ' || c == '\n') && !t->bit_count)  {
        return PARSE_OK;
    }

    /* If delimiter is reached before 8 bits, advance the buffer_index pointer
     * to the next set of 8 bits, reset the current bit count, and increment
     * the token counter */
    else if ((c == ' ' || c == '\n') && t->buffer_index % 8) {
        t->buffer_index += 8 - (t->buffer_index % 8);
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* If no delimiter was found before the end of the 8 bits,
     * the input is incorrectly formatted and should be rejected */
    else if (c != ' ' && t->bit_count >= 8) {
        return PARSE_FAIL;
    }

    /* If we've hit the delimiter at the correct position, meaning
     * the user has entered 8 bits and then hit a space, reset the bit
     * counter, increment the token count and continue parsing */
    else if(c == ' ' && t->bit_count == 8) {
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* Last case represents entering an additional bit within the bounds
     * of the token. Record the character, increment the buffer index and
     * bit counter and continue parsing */
    else {
        token_buffer[t->buffer_index++] = c;
        t->bit_count++;
        return PARSE_OK;
    }
}


char read_char_primitive(FILE *file, int fd, int mode, struct token_indices *t, char *buf) {
    
    /* Get characters read and persist data on each call */
    static int ret;
    
    /* If we are reading from a file, get the file descriptor required by read(), otherwise use 0 for stdin */
    fd = mode == READ_FROM_FILE ? fileno(file) : 0;
    
    /* Make a single call to call to read() a fill the given buffer */
    if (!t->read_buffer_index) {
        ret = read(fd,buf, BUFFER_SIZE);
        if (!ret) return EOF;
    }

    /* As soon as our index into the buffer filled by read() is at last byte returned by read, return EOF */
    if (t->read_buffer_index == ret) {
        return EOF;
    }

    /* Otherwise return a single character from the buffer indexed by values in *t */
    return buf[t->read_buffer_index++];
}
