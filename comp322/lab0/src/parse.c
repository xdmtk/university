#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* For read() declaration - unistd.h does not exist in Windows */
#ifdef __linux__
    #include <unistd.h>
    #include <fcntl.h>
#elif WIN32
    #include <io.h>
#endif

#include <lab0/main.h>
#include <lab0/parse.h>


/**
 * Parses and tokenizes the contents of the specified
 * file.
 * @param file_path - Input file path
 * @param len - Amount of tokens successfully parsed
 * @param mode - Mode to read from STDIN or File
 * @return  - Pointer to array of string literals representing
 * file contents as tokens
 */
char **read_tokens(char *file_path, size_t *len, int mode, char **argv, int argc) {

    /* Declarations */
    int fd;
    char * token_buffer, read_token_buffer[BUFFER_SIZE], c;
    struct token_indices t;
    int i, k, parse_status = PARSE_OK, token_arg_len;

    /* Zero counters, allocate the buffer space and zero it out */
    t.buffer_index = t.token_count = t.bit_count = t.read_buffer_index = 0;
    token_buffer = malloc(sizeof(char)*BUFFER_SIZE);
    for (i=0; i < BUFFER_SIZE; ++i) token_buffer[i] = '0';


    if (mode == READ_FROM_FILE) {
        fd = open(file_path, 0);

        /* Begin reading character by character, using read_char_primitive as a wrapper around read()
         * and mimic the functionality of fgetc() / getchar() */
        while (((c = read_char_primitive(fd, &t, read_token_buffer)) != EOF) && (parse_status != PARSE_FAIL)) {

            /* Parse the character and return a parse status */
            parse_status = tokenize(c, token_buffer, &t);
        }
        /* Increment the final token count after the last character has been parsed */
        ++t.token_count;
    }
    else {

        /* If we are parsing tokens from stdin, just copy each argument into the token buffer */
        for (i = 1, k = 0; i < argc; ++i) {

            if (!strcmp(argv[i], "-")) continue;

            memcpy(token_buffer+k, argv[i], (token_arg_len = strlen(argv[i])) > 8 ? 8 : token_arg_len);
            k += 8;
            t.token_count++;
        }
    }
    *len = t.token_count;

    /* If parse status is OK, return the token list generated by append_tokens(), otherwise
     * return NULL */
    return parse_status != PARSE_FAIL ? append_tokens(token_buffer, &t) : NULL;
}


/**
 * Appends a token from the token buffer to the dynamically allocated
 * list of tokens.
 *
 * @param tokens
 * @param token_buffer
 * @param t
 */
char ** append_tokens(char *tokens, struct token_indices *t) {

    int i;
    /* Allocate a list of char pointers */
    char ** token_list = malloc(sizeof(char *)*t->token_count);

    /* Begin allocating and copying tokens from the token buffer */
    for (i = 0; i < t->token_count; ++i) {

        token_list[i] = malloc(sizeof(char)*9);
        memcpy(token_list[i], tokens+(i*8), 8);

        /* Null terminate each string */
        token_list[i][8] = '\0';
    }

    /* Return the list of tokens */
    return token_list;
}


/**
 * Called to operate on each character read and determine the current
 * status of the parse. Checks for delimiters and EOF conditions
 *
 * @param c
 * @param token_buffer
 * @param file_tokens
 * @param t
 * @return
 */
int tokenize(char c, char* token_buffer, struct token_indices *t) {

    /* If we've hit a delimiter but have no bits entered yet
     * we can safely ignore. This can happen with input where tokens
     * have multiple spaces separating them
     *
     * Example: 1101       1110 01      1000
     */
    if ((c == ' ' || c == '\n') && !t->bit_count)  {
        return PARSE_OK;
    }

    /* If delimiter is reached before 8 bits, advance the buffer_index pointer
     * to the next set of 8 bits, reset the current bit count, and increment
     * the token counter */
    else if ((c == ' ' || c == '\n') && t->buffer_index % 8) {
        t->buffer_index += 8 - (t->buffer_index % 8);
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* If no delimiter was found before the end of the 8 bits,
     * we can ignore any continued 0 or 1's */
    else if (c != ' ' && c != '\n' && t->bit_count >= 8) {
        return PARSE_OK;
    }

    /* If we've hit the delimiter at the correct position, meaning
     * the user has entered 8 bits and then hit a space, reset the bit
     * counter, increment the token count and continue parsing */
    else if((c == ' ' || c == '\n') && t->bit_count == 8) {
        t->bit_count = 0;
        t->token_count++;
        return PARSE_OK;
    }

    /* Last case represents entering an additional bit within the bounds
     * of the token. Record the character, increment the buffer index and
     * bit counter and continue parsing */
    else {
        token_buffer[t->buffer_index++] = c;
        t->bit_count++;
        return PARSE_OK;
    }
}



/**
 * Since we aren't allowed to use getchar() or fgetc() for I/O,
 * this wrapper around read() simulates getchar()/fgetc()
 * @param fd
 * @param mode
 * @return
 */
char read_char_primitive(int fd, struct token_indices *t, char *buf) {
    
    /* Get characters read and persist data on each call */
    static int ret;
    
    /* Make a single call to call to read() a fill the given buffer */
    if (!t->read_buffer_index) {
        ret = read(fd,buf, BUFFER_SIZE);
        if (!ret) return EOF;
    }

    /* As soon as our index into the buffer filled by read() is at last byte returned by read, return EOF */
    if (t->read_buffer_index == ret) {
        return EOF;
    }

    /* Otherwise return a single character from the buffer indexed by values in *t */
    return buf[t->read_buffer_index++];
}
